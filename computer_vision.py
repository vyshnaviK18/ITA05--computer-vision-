# -*- coding: utf-8 -*-
"""computer vision.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_fdv8i0FgzUfAin68BRpk8wZ9uZeX0zn
"""

"""1. Perform basic Image Handling and processing operations on the image. • Read an image in python
and Convert an Image to Grayscale"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
kernel = np.ones((5,5),np.uint8)
print(kernel)
path = "/content/1330919.jpeg"
img =cv2.imread(path)
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
cv2_imshow(imgGray)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""2. Perform basic Image Handling and processing operations on the image.• Read an image in python
and Convert an Image to Blur using GaussianBlur."""

import cv2
from google.colab.patches import cv2_imshow

image_path = "/content/1330919.jpeg"
image = cv2.imread(image_path)
blurred_image = cv2.GaussianBlur(image, (5, 5), 0)
print('Original Image')
cv2_imshow(image)
print('Blurred Image')
cv2_imshow(blurred_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""3. Perform basic Image Handling and processing operations on the image• Read an image in python
and Convert an Image to show outline using Canny function"""
import cv2
from google.colab.patches import cv2_imshow

import numpy as np
kernel = np.ones((5,5),np.uint8)
print(kernel)
path = "/content/1330919.jpeg"
img =cv2.imread(path)
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
imgBlur = cv2.GaussianBlur(imgGray,(7,7),0)
imgCanny = cv2.Canny(imgBlur,100,200)
desired_width = 800
desired_height = 600
img_resized = cv2.resize(imgCanny, (desired_width, desired_height))
print("Img Canny")
cv2_imshow(img_resized)
cv2.waitKey(0)

"""4. Perform basic Image Handling and processing operations on the image• Read an image in python
and Dilate an Image using Dilate function"""

import cv2
from google.colab.patches import cv2_imshow

import numpy as np
kernel = np.ones((5,5),np.uint8)
print(kernel)
path = "/content/1330919.jpeg"
img =cv2.imread(path)
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
imgBlur = cv2.GaussianBlur(imgGray,(7,7),0)
imgCanny = cv2.Canny(imgBlur,100,200)
imgDilation = cv2.dilate(imgCanny,kernel , iterations = 10)
imgEroded = cv2.erode(imgDilation,kernel,iterations=2)
print("Img Erosion")
cv2_imshow(imgEroded)
cv2.waitKey(0)

"""5. Perform basic Image Handling and processing operations on the image• Read an image in python
and Erode an Image using erode function"""

import cv2
from google.colab.patches import cv2_imshow

import numpy as np
kernel = np.ones((5,5),np.uint8)
print(kernel)
path = "/content/WIN_20231123_11_26_51_Pro.jpg"
img =cv2.imread(path)
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
imgBlur = cv2.GaussianBlur(imgGray,(7,7),0)
imgCanny = cv2.Canny(imgBlur,100,200)
imgDilation = cv2.dilate(imgCanny,kernel , iterations = 10)
imgEroded = cv2.erode(imgDilation,kernel,iterations=2)
print("Img Erosion")
cv2_imshow(imgEroded)
cv2.waitKey(0)

"""6. Perform basic video processing operations on the captured video• Read captured video in python
and display the video, in slow motion and in fast motion."""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
cap = cv2.VideoCapture("/content/00030.mp4")
if (cap.isOpened()== False):
  print("Error opening video file")
while(cap.isOpened()):
  ret, frame = cap.read()
  if ret == True:
    cv2_imshow(frame)
    if cv2.waitKey(250) & 0xFF == ord('q'):
      break
  else:
    break
cap.release()
cv2.destroyAllWindows()

"""7. Capture video from web Camera and Display the video, in slow motion and in fast motion
operations on the captured video"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
cap = cv2.VideoCapture("/content/WIN_20231123_11_29_40_Pro.mp4")
if (cap.isOpened()== False):
  print("Error opening video file")
while(cap.isOpened()):
  ret, frame = cap.read()
  if ret == True:
    cv2_imshow(frame)
    break
  else:
    break
cap.release()
cv2.destroyAllWindows()

"""8. Scaling an image to its Bigger and Smaller sizes"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
kernel = np.ones((5,5),np.uint8)
img = cv2.imread("/content/R.jpg")
img = cv2.resize(img,(600,600))
cv2_imshow(img)
cv2.waitKey(0)

#9. Perform Rotation of an image to clockwise and counter clockwise direction.

import cv2
path =r"/content/R.jpg"
src = cv2.imread(path)
window_name = 'Image'
image = cv2.rotate(src, cv2.ROTATE_180)
cv2_imshow(image)
cv2.waitKey(0)

#ROTATION ALONG 180 DEGREE
import cv2
path = r"/content/R.jpg"
src = cv2.imread(path)
window_name = 'Image'
image = cv2.rotate(src, cv2.ROTATE_90_COUNTERCLOCKWISE)
# Displaying the image
cv2_imshow(image)
cv2.waitKey(0)

# 11. Perform Affine Transformation on the image

#import cv2
import numpy as np
# read the input image
img = cv2.imread("/content/R.jpg")
# access the image height and width
rows,cols,_ = img.shape
# define at three point on input image
pts1 = np.float32([[50,50],[200,50],[50,200]])
# define three points corresponding location to output image
pts2 = np.float32([[10,100],[200,50],[100,250]])
# get the affine transformation Matrix
M = cv2.getAffineTransform(pts1,pts2)
# apply affine transformation on the input image
dst = cv2.warpAffine(img,M,(cols,rows))
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

#12. Perform Perspective Transformation on the image.
import cv2
import numpy as np
# read the input image
img = cv2.imread("/content/R.jpg")
# find the height and width of image
# width = number of columns, height = number of rows in image array
rows,cols,ch = img.shape
# define four points on input image
pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
# define the corresponding four points on output image
pts2 = np.float32([[100,50],[300,0],[0,300],[300,300]])
# get the perspective transform matrix
M = cv2.getPerspectiveTransform(pts1,pts2)
# transform the image using perspective transform matrix
dst = cv2.warpPerspective(img,M,(cols, rows))
# display the transformed image
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

#13. Perform Perspective Transformation on the Video.

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

cap = cv2.VideoCapture("/content/Mountain and Forest Activities   Taiwan Tourism Video 30 seconds.mp4")
while True:
  ret, frame = cap.read()
  pts1 = np.float32([[200,300], [5, 2],[0, 4], [6, 0]])
  pts2 = np.float32([[0, 0], [4, 0],[0, 1], [4, 6]])
  matrix = cv2.getPerspectiveTransform(pts1, pts2)
  result = cv2.warpPerspective(frame, matrix, (0, 0))
  cv2_imshow(frame) # Initial Capture
  cv2_imshow(result) # Transformed Capture
  break
cap.release()
cv2.destroyAllWindows()

#14. Perform transformation using Homography matrix

import cv2
import numpy as np
# Read source image.
im_src = cv2.imread("/content/R.jpg")
# Four corners of the book in source image
pts_src = np.array([[141, 131], [480, 159], [493, 630],[64, 601]])
# Read destination image.
im_dst = cv2.imread("/content/R.jpg")
# Four corners of the book in destination image.
pts_dst = np.array([[318, 256],[534, 372],[316, 670],[73, 473]])
# Calculate Homography
h, status = cv2.findHomography(pts_src, pts_dst)
# Warp source image to destination based on homography
im_out = cv2.warpPerspective(im_src, h, (im_dst.shape[1],im_dst.shape[0]))
# Display images
cv2_imshow(im_src)
cv2_imshow(im_dst)
cv2_imshow(im_out)
cv2.waitKey(0)

#15. Perform transformation using Direct Linear Transformation

import cv2
import numpy as np
# Load images
img1 = cv2.imread("/content/R.jpg")
img2 = cv2.imread("/content/R.jpg")
# Define corresponding points
pts1 = np.array([[50, 50], [200, 50], [50, 200], [200, 200]])
pts2 = np.array([[100, 100], [300, 100], [100, 300], [300, 300]])
# Estimate projective transformation matrix using DLT
H, _ = cv2.findHomography(pts1, pts2)
# Apply projective transformation to img1
dst = cv2.warpPerspective(img1, H, (img2.shape[1], img2.shape[0]))
# Display images
cv2_imshow(img1)
cv2_imshow(img2)
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

#16. Perform Edge detection using canny method

import cv2
img = cv2.imread("/content/R.jpg")
cv2_imshow(img)
cv2.waitKey(0)
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)
edges = cv2.Canny(image=img_blur, threshold1=100, threshold2=200) # Canny Edge Detection
cv2_imshow(edges)
cv2.waitKey(0)
cv2.destroyAllWindows()

#17. Perform Edge detection using Sobel Matrix along X axis


import cv2
img = cv2.imread("/content/R.jpg")
cv2_imshow(img)
cv2.waitKey(0)
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Blur the image for better edge detection
img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)
sobelx = cv2.Sobel(src=img_blur, ddepth=cv2.CV_64F, dx=1, dy=0, ksize=5) # Sobel Edge Detection on the X axis
cv2_imshow(sobelx)
cv2.waitKey(0)

import cv2
# 18. Perform Edge detection using Sobel Matrix along Y axis

img = cv2.imread("/content/R.jpg")
# Display original image
cv2_imshow(img)
cv2.waitKey(0)
# Convert to graycsale
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Blur the image for better edge detection
img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)
# Sobel Edge Detection
sobely = cv2.Sobel(src=img_blur, ddepth=cv2.CV_64F, dx=0, dy=1, ksize=5) # Sobel Edge Detection on the Y axis
# Display Sobel Edge Detection Images
cv2_imshow(sobely)
cv2.waitKey(0)

import cv2
img = cv2.imread("/content/R.jpg")
# 19. Perform Edge detection using Sobel Matrix along XY axis

cv2_imshow(img)
cv2.waitKey(0)
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Blur the image for better edge detection
img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)
sobelxy = cv2.Sobel(src=img_blur, ddepth=cv2.CV_64F, dx=1, dy=1, ksize=5) # Combined X and Y Sobel Edge Detection
cv2_imshow(sobelxy)
cv2.waitKey(0)

#20. Perform Sharpening of Image using Laplacian mask with negative center coefficient.
import cv2
import numpy as np
img = cv2.imread("/content/R.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
kernel = np.array([[0,1,0], [1,-8,1], [0,1,0]])
sharpened = cv2.filter2D(gray, -1, kernel)
cv2_imshow(gray)
cv2_imshow(sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()

'''21 Perform Sharpening of Image using Laplacian mask implemented with an extension of
diagonal neighbors,

PROGRAM '''
from google.colab.patches import cv2_imshow
import cv2
import numpy as np
img = cv2.imread("/OIP.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
kernel = np.array([[0,1,0], [1,-4,1], [0,1,0]])
sharpened = cv2.filter2D(gray, -1, kernel)
cv2_imshow(gray)
cv2_imshow(sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()

'''22 Perform Sharpening of Image using Laplacian mask with positive center coefficient.
'''
import cv2
import numpy as np
img = cv2.imread("/OIP.jpg")
img = cv2.resize(img,(255, 255))
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Apply the Laplacian filter with a positive center coefficient
laplacian_kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
sharpened_img = cv2.filter2D(gray_img, -1, laplacian_kernel)
sharpened_img = cv2.cvtColor(sharpened_img, cv2.COLOR_GRAY2BGR)
cv2_imshow(img)
cv2_imshow(sharpened_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

#23 Perform Sharpening of Image using unsharp masking.

import cv2
import numpy as np
img = cv2.imread("/OIP.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
laplacian_kernel = np.array([[0, 1, 0],
 [1, -4, 1],
 [0, 1, 0]])
laplacian = cv2.filter2D(gray, -1, laplacian_kernel)
sharpened = cv2.add(gray, laplacian)
cv2_imshow(gray)
cv2_imshow(sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()

#24 Perform Sharpening of Image using High-Boost Masks.

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
img = cv2.imread('/1330919.jpeg')

# Convert the image to grayscale
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply a Gaussian blur to the grayscale image (low-pass filter)
blurred_img = cv2.GaussianBlur(gray_img, (5, 5), 0)

# Calculate the high-boost mask
mask = gray_img - blurred_img

# Choose a scaling factor (e.g., alpha = 2 for a simple example)
alpha = 2

# Apply the high-boost filter
sharpened_img = gray_img + alpha * mask

# Clip the values to be in the valid range [0, 255]
sharpened_img = np.clip(sharpened_img, 0, 255).astype(np.uint8)

# Display the original and sharpened images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(gray_img, cmap='gray')
plt.title('Original Image')

plt.subplot(1, 2, 2)
plt.imshow(sharpened_img, cmap='gray')
plt.title('Sharpened Image')

plt.show()

#25 Perform Sharpening of Image using Gradient masking
import cv2
import numpy as np

# Load the image
a = cv2.imread("/R.jpg", cv2.IMREAD_GRAYSCALE)

# Laplacian kernel
laplacian_kernel = np.array([[0, 1, 0],
                             [1, -4, 1],
                             [0, 1, 0]], dtype=np.float32)

# Gradient kernel
gradient_kernel = np.array([[-1, -1, -1],
                            [-1,  8, -1],
                            [-1, -1, -1]], dtype=np.float32)

# Perform convolution with Laplacian kernel
a1 = cv2.filter2D(a, -1, laplacian_kernel)

# Perform convolution with Gradient kernel
a3 = cv2.filter2D(a, -1, gradient_kernel)

# Display the original, Laplacian, and Gradient images
cv2_imshow(a)
print('Laplacian Sharpened Image')
cv2_imshow(a1)
print('Gradient Sharpened Image' )
cv2_imshow(a3)

cv2.waitKey(0)
cv2.destroyAllWindows()

#26 Insert water marking to the image using OpenCV.

import cv2
img = cv2.imread("/R.jpg")
wm = cv2.imread("/OIP.jpg")
h_wm, w_wm = wm.shape[:2]
h_img, w_img = img.shape[:2]
center_x = int(w_img/2)
center_y = int(h_img/2)
top_y = center_y - int(h_wm/2)
left_x = center_x - int(w_wm/2)
bottom_y = top_y + h_wm
right_x = left_x + w_wm
roi = img[top_y:bottom_y, left_x:right_x]
result = cv2.addWeighted(roi, 1, wm, 0.3, 0)
img[top_y:bottom_y, left_x:right_x] = result
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

#27. Do Cropping, Copying and pasting image inside another image using OpenCV

import cv2
import numpy as np
image = cv2.imread("/1330919.jpeg")
img2 = cv2.imread('/OIP.jpg')
print(image.shape) # Print image shape

img2_resized = cv2.resize(img2, (image.shape[1], image.shape[0]))

# Blend the two images
dst = cv2.addWeighted(image, 0.5, img2_resized, 0.7, 0)

# Display the blended image
print('Blended Image')
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

#28. Find the boundary of the image using Convolution kernel for the given image

import cv2
import numpy as np
img = cv2.imread("/OIP.jpg",
cv2.IMREAD_GRAYSCALE)
dx = cv2.Sobel(img, cv2.CV_64F, 1, 0)
dy = cv2.Sobel(img, cv2.CV_64F, 0, 1)
edges = cv2.magnitude(dx, dy)
thresh = 100
edges[edges < thresh] = 0
edges[edges >= thresh] = 255
cv2_imshow(edges)
cv2.waitKey(0)
cv2.destroyAllWindows()

#29. Morphological operations based on OpenCV using Erosion technique

import cv2
import numpy as np
img = cv2.imread("/R.jpg", cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
erosion = cv2.erode(img, kernel, iterations=1)
cv2_imshow(img)
cv2_imshow(erosion)
cv2.waitKey(0)
cv2.destroyAllWindows()

#30. Morphological operations based on OpenCV using Dilation technique

import cv2
import numpy as np
img = cv2.imread("/OIP.jpg", cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
dilation = cv2.dilate(img, kernel, iterations=1)
cv2_imshow(img)
cv2_imshow(dilation)
cv2.waitKey(0)
cv2.destroyAllWindows()

#31. Morphological operations based on OpenCV using Opening technique.

import cv2
import numpy as np
img = cv2.imread("/OIP.jpg", cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

cv2_imshow(opening)
cv2.waitKey(0)
cv2.destroyAllWindows()

#32. Morphological operations based on OpenCV using Closing technique.

import cv2
import numpy as np
img = cv2.imread("/R.jpg", cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)

cv2_imshow(closing)
cv2.waitKey(0)
cv2.destroyAllWindows()

#33. Morphological operations based on OpenCV using Morphological Gradient technique


import cv2
import numpy as np
img = cv2.imread("/R.jpg", cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
grad = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)

cv2_imshow(grad)
cv2.waitKey()

#34. Morphological operations based on OpenCV using Top hat technique.


import cv2
import numpy as np
img = cv2.imread("/R.jpg",
cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)

cv2_imshow(tophat)
cv2.waitKey(0)
cv2.destroyAllWindows()

#35. Morphological operations based on OpenCV using Black hat technique.

import cv2
import numpy as np
img = cv2.imread("/R.jpg",
cv2.IMREAD_GRAYSCALE)
kernel = np.ones((5,5), np.uint8)
blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)

cv2_imshow(blackhat)
cv2.waitKey(0)
cv2.destroyAllWindows()

#36. Recognise watch from the given image by general Object recognition using OpenCV.

import cv2
watch_cascade = cv2.CascadeClassifier("C:/Users/divya/OneDrive/Documents/COMPUTER VISION/watch-cascade.xml")
img = cv2.imread("C:/Users/divya/OneDrive/Documents/COMPUTER VISION/COMPUTER VISION/watch.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
watches = watch_cascade.detectMultiScale(gray, scaleFactor=1.2, minNeighbors=5)
for (x, y, w, h) in watches:
 cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)
cv2.imshow('Watches Detected', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

#37. Using Opencv play Video in Reverse mode.

import cv2
cap = cv2.VideoCapture("/content/Mountain and Forest Activities   Taiwan Tourism Video 30 seconds.mp4")
total_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)
current_frame = total_frames - 1
while current_frame >= 0:
 cap.set(cv2.CAP_PROP_POS_FRAMES, current_frame)
 ret, frame = cap.read()
 if not ret:
  break
 cv2_imshow(frame)
 if cv2.waitKey(25) & 0xFF == ord('q'):
  break
 current_frame -= 1
cap.release()
cv2.destroyAllWindows()

#38. Face Detection using Opencv

import cv2
img = cv2.imread("/R.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
face_cascade =
cv2.CascadeClassifier("C:/Users/koppo/Downloads/haarcascade_frontalface_default.xml")
faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)
for (x, y, w, h) in faces:
 cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

#39. Vehicle Detection in a Video frame using OpenCV

import cv2
car_cascade = cv2.CascadeClassifier("C:/Users/divya/OneDrive/Documents/COMPUTER VISION/cars.xml")
cap = cv2.VideoCapture("C:/Users/divya/Downloads/car.mp4")
while True:
 ret, frame = cap.read()
 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
 cars = car_cascade.detectMultiScale(gray, 1.1, 1)
 for (x,y,w,h) in cars:
 cv2.rectangle(frame, (x,y), (x+w,y+h), (0,0,255), 2)
 cv2_imshow(frame)
 if cv2.waitKey(1) & 0xFF == ord('q'):
 break
cap.release()
cv2.destroyAllWindows()

#40. Draw Rectangular shape and extract objects



import cv2
img = cv2.imread("/R.jpg")
x, y = 100, 100
width, height = 200, 150
roi = img[y:y+height, x:x+width]
cv2_imshow(roi)
cv2.waitKey(0)
cv2.destroyAllWindows()